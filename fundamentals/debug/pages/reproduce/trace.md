# 버그 발생 경로를 추적하기

디버깅을 하다 보면, **버그의 결과만 기억하고 그 과정은 놓치기 쉬워요**. 언제 어떤 흐름으로 문제가 발생했는지는 막상 떠올리기 어렵고, 시간이 지나면 더 희미해져요.

하지만 많은 버그는 단순한 동작 하나로 생기지 않아요. **특정한 실행 순서나 상태 변화가 누적되어야만 발생하는 경우가 많아요**. 예를 들어 같은 버튼을 눌러도, 그 전에 어떤 페이지를 거쳤는지, 어떤 모달을 열었는지, 어떤 입력을 했는지에 따라 전혀 다른 상황이 만들어질 수 있어요.

그래서 **이벤트가 실행된 경로와 상태 변화 과정을 정확히 기록해 두는 것**이 중요해요. 이렇게 하면 문제를 안정적으로 재현할 수 있고, 복잡한 상태 의존 버그도 더 쉽게 분석할 수 있어요.


## UI 상의 모든 상호작용을 기록하기
- 어떤 버튼을 눌렀는지, 어떤 입력을 했는지 등 **눈에 보이는 조작을 빠짐없이 적어두는 것**이 좋아요.
- 특히 페이지 이동, 탭 전환, 모달 열기·닫기 같은 UI 조작은 상태 변화에 큰 영향을 줄 수 있어요.
- '1번 항목 클릭 → 모달 열기 → 확인 버튼 클릭'처럼 **사용자 행동을 순서대로 기록**하면 재현이 쉬워져요.


## 이전 상태 기록하기
**이전 상태가 현재 동작에 영향을 줄 수 있어요**
- 버그가 발생한 화면만 보지 말고, **그 전에 어떤 상태였는지를 함께 살펴봐야 해요.**
- 예: “이전 페이지에서 특정 항목을 선택한 후 이 화면으로 넘어왔을 때만 발생함”처럼, **이전 컨텍스트가 조건이 되는 경우**가 많아요.

## 예시
이런 흐름 기반 버그의 대표적 예시로, 웹뷰 간 상태 동기화 문제를 살펴볼게요.

- **웹뷰 A**: 게시글 리스트 페이지 (`/posts`)
    - `useQuery(['posts'])`로 전체 목록을 불러옴
- **웹뷰 B**: 게시글 상세 페이지 (`/posts/:postId`)
    - `useQuery(['post', postId])`로 단일 게시글 로드
    - 수정 시 `queryClient.setQueryData(['posts'], ...)`로 리스트 캐시까지 갱신

### 기대 동작

- 상세 페이지에서 게시글 제목을 수정하면 리스트에서도 변경된 제목이 반영되어야 해요.
- 어떤 순서로 접근하든 동일한 결과가 나와야 해요.

### 실행 순서에 따른 결과 차이

- `B → A → B`: 첫 진입 시 수정된 데이터를 잘 보여주지만,
두 번째 B 진입 시 캐시 구조 문제로 잘못된 데이터가 노출돼요.

| 경로 | 동작 | 결과 |
| --- | --- | --- |
| A → B → A | 상세에서 수정하고 리스트에 돌아오면 리스트도 갱신됨 | ✅ 정상 |
| B → A → B | 상세에서 수정한 후, 리스트에 갔다가 다시 상세로 오면 **이전 값이 보임** 또는 잘못된 데이터 구조 | ❌ 문제 발생 |

### 코드 예시

```tsx 4,9
const queryClient = useQueryClient();

const updatePostTitle = (postId: number, newTitle: string) => {
  queryClient.setQueryData(['post', postId], (prev: any) => ({
    ...prev,
    title: newTitle,
  }));

  queryClient.setQueryData(['posts'], (old: any) => {
    if (!old) return old;

    return old.map((post: any) =>
      post.id === postId ? { ...post, title: newTitle } : post
    );
  });
};
```

### 문제의 핵심
- **`['posts']` 캐시가 존재하지 않을 수도 있는 상태**에서 `setQueryData`가 실행됨
- 또는 기존에 존재하던 캐시 구조와 `['post', postId]` 구조가 다르게 맞춰져 있어 구조 충돌 발생
- 두 번째로 상세 페이지에 진입할 때 `['post', postId]` 캐시가 오염된 상태로 유지됨

이 예시는 "리스트 캐시를 수동 갱신하면서, 의도치 않게 상세 캐시를 망가뜨리는" 상황을 보여줘요.

특히 실행 순서(B → A → B)에 따라 캐시 구조가 꼬이고, 이후 조회에서 **예상과 다른 결과가 나오는 현상**을 쉽게 재현할 수 있어요.


이처럼 실행 흐름을 추적하고 재현에 활용하면, “언제는 되고, 언제는 안 되는” 상태 기반 버그를 안정적으로 해결할 수 있어요.
